# 1. 三元表达式

* 1.另一种if判断

  ```python
  print("a" and "b" or "c", "" and "/d/")
  print("" and "b" or "c", "" and "/d/")
  ```

* 结果

  ```markdown
  b
  c /d/
  ```

# 2. 正则

## 2.1 re.VERBOSE使用

* ```python
  _rule_re = re.compile(
  	r"""
  		(?aa)
  		<
  		(?:
  			(a)
  			(b)
  		)?
  		(?ji)
  	""",
      re.VERBOSE,
  )
  ```

* 作用

  * ```
    可以把正则表达式写成多行，并且自动忽略空格
    ```

  ## 2.2 re.UNICODE：全球通用的，统一的

  * ```python
    # 设置，就会影响到\w,\W,\b,\B,\d,\D,\s,\S
    _rule_re = re.compile(
    	r"""
    		(?aa)
    		<
    		(?:
    			(a)
    			(b)
    		)?
    		(?ji)
    	""",
        re.UNICODE,
    )
    ```

*  



## 2.3 非捕获元

* 非捕获元

  * ```python
    (?:...)  	正则括号的非捕获版本。 匹配在括号内的任何正则表达式，但该分组所匹配的子字符串 不能 在执行匹配后被获取或是之后在模式中被引用
    (?=...)		前视断定，匹配...的内容，但是并不消费样式的内容
    (?!...)		前视断定取反，匹配...不符合的情况
    (?<=...)	后视断定 匹配字符串的当前位置，它的前面匹配...的内容到当前位置
    (?<!...)	后视断定取反，匹配当前位置之前不是...的样式
    ```

* (?=...)

  * ```python
    # Isaac (?=Asimov) 匹配 'Isaac ' 只有在后面是 'Asimov' 的时候
    data = re.findall(r'Isaac (?=Asimov)', "Isaac Asimov")
    print(data)
    #结果：['Isaac ']
    ```
  
* (?!...)

  * ```python
    # Isaac (?!Asimov) 只有后面 不 是 'Asimov' 的时候才匹配 'Isaac '
    data = re.findall(r'Isaac (?!Asimov)', "Isaac Asimov")
    print(data)
    #结果：[]
    ```
  
* (?:...)

  * ```python
    # 匹配在括号内的任何正则表达式，但不被引用
    content = "http://google0.com http://code.google1.com"
    data = re.findall(r'http://(?:\w+\.)*(\w+\.com)', content)
    print(data)
    
    # 结果：['google0.com', 'google1.com']
    ```

* (?<=...)

  * ```python
    # 匹配字符串的当前位置，它的前面匹配...的内容到当前位置
    # 示例1
    data = re.findall(r'(?<=abc)def', "abcdef")
    print(data)
    # 结果：['def']
    
    # 示例2
    data = re.findall(r'(?<=-)\w+', "spam-egg")
    print(data)
    # 结果：['egg']
    ```

* (?<!...)

  * ```python
    # 匹配当前位置之前不是 ... 的样式
    # 示例1
    data = re.findall(r'(?<!abc)def', "abcdef")
    print(data)
    # 结果：[]
    
    data = re.findall(r'(?<!-)\w+', "spam-egg")
    print(data)
    # 结果：['spam', 'gg']
    
    # 示例2
    
    ```

    

# 3.zip

> zip([iterable, ...])
>
> 参数说明：iterable   一个或多个迭代器

* 示例

  ```python
  a = [1,2,3]
  b = [4,5,6]
  c = [4,5,6,7,8]
  zipperd = zip(a,b)	# 打包为元组的列表
  # 结果：[(1, 4), (2, 5), (3, 6)]
  
  zip(a,c)	# 元素个数与最短的列表一致
  # 结果：[(1, 4), (2, 5), (3, 6)]
  
  zip(*zipped)	# 与zip相反，*zipped可以理解为解压，返回二维矩阵式
  # 结果：[(1, 2, 3), (4, 5, 6)]
  ```

  

# 4.repeat

```
from itertools import repeat
```

> 重复单个值

* 示例

  * ```python
    data = zip([9,2,3],repeat(1))
    for i in data:
        print(i)
        
    # 结果：
        (9, 1)
        (2, 1)
        (3, 1)
    ```

    

# 5. **\_\_reduce\_\_** 或  **\_\_reduce_ex\_\_** 



## 5.1  **\_\_reduce\_\_** 

> \_\_reduce\_\_ ()方法不带任何参数，并且应返回字符串或最好返回一个元组(返回的对象通常称为“reduce”值)

* 返回字符串

  ```
  该字符串会被当成一个全局变量的名称，它应该是对象相对于其模块的本地名称，pickle 模块会搜索模块命名空间来确定对象所属的模块。这种行为常在单例模式使用
  ```

* 如果返回的是元组

  > 则应当包含 2 到 6 个元素，可选元素可以省略或设置为 `None`。每个元素代表的意义如下：

  * | 元素                                               | 说明                                                         |
    | -------------------------------------------------- | ------------------------------------------------------------ |
    | 一个可调用对象                                     | 该对象会在创建对象的最初版本时调用                           |
    | 可调用对象的参数，是一个元组                       | 如果可调用对象不接受参数，必须提供一个空元组                 |
    | 可选元素,用于表示对象的状态                        | 将被传给前述的 [`__setstate__()`](https://docs.python.org/zh-cn/3/library/pickle.html?highlight=__reduce__#object.__setstate__) 方法。 如果对象没有此方法，则这个元素必须是字典类型，并会被添加至 [`__dict__`](https://docs.python.org/zh-cn/3/library/stdtypes.html#object.__dict__) 属性中 |
    | 可选元素,一个返回连续项的迭代器（而不是序列）      | 这些项会被 `obj.append(item)` 逐个加入对象，或被 `obj.extend(list_of_items)` 批量加入对象。这个元素主要用于 list 的子类，也可以用于那些正确实现了 `append()` 和 `extend()` 方法的类。（具体是使用 `append()` 还是 `extend()` 取决于 pickle 协议版本以及待插入元素的项数，所以这两个方法必须同时被类支持。） |
    | 可选元素，一个返回连续键值对的迭代器（而不是序列） | 这些键值对将会以 `obj[key] = value` 的方式存储于对象中。该元素主要用于 dict 子类，也可以用于那些实现了 [`__setitem__()`](https://docs.python.org/zh-cn/3/reference/datamodel.html#object.__setitem__) 的类。 |
    | 可选元素，一个带有 `(obj, state)` 签名的可调用对象 | 该可调用对象允许用户以编程方式控制特定对象的状态更新行为，而不是使用 `obj` 的静态 [`__setstate__()`](https://docs.python.org/zh-cn/3/library/pickle.html?highlight=__reduce__#object.__setstate__) 方法。如果此处不是 `None`，则此可调用对象的优先级高于 `obj` 的 [`__setstate__()`](https://docs.python.org/zh-cn/3/library/pickle.html?highlight=__reduce__#object.__setstate__)。 |

    

  ## 5.1  **\_\_reduce_ex\_\_**

  * ```
    作为替代选项，也可以实现 __reduce_ex__() 方法。 此方法的唯一不同之处在于它应接受一个整型参数用于指定协议版本。 如果定义了这个函数，则会覆盖 __reduce__() 的行为。 此外，__reduce__() 方法会自动成为扩展版方法的同义词。 这个函数主要用于为以前的 Python 版本提供向后兼容的 reduce 值。
    ```


# 6. 字符串

* %r

  > 直接返回本体

  ```python
  # 示例一：
  data = "data %r" %123
  print(data)
  # 结果：data 123
  
  # 示例二
  data = "data %r" % "123"
  print(data)
  # 结果：data '123'
  ```

  

# 7. Ast

> Abstract Syntax Trees即抽象语法树
>
> Ast是python源码到字节码的一种中间产物，借助ast模块可以从语法树的角度分析源码结构

* CPython解析器对python源码的处理过程

  > 源代码解析 --> 语法树 --> 抽象语法树(AST) --> 控制流程图 --> 字节码

  * ```markdown
    1. 将源代码解析为解析树（Parser / pgen.c）
    2. 将解析树转换为抽象语法树（Python / ast.c）
    3. 将AST转换为控制流图（Python / compile.c）
    4. 根据控制流程图（Python / compile.c）发出字节码
    ```

## 7.1 Compile函数

> compile(source, filename, mode[, flags[, dont_inherit]])

* ```markdown
  source -- 字符串或者AST（Abstract Syntax Trees）对象。一般可将整个py文件内容file.read()传入。
  filename -- 代码文件名称，如果不是从文件读取代码则传递一些可辨认的值。
  mode -- 指定编译代码的种类。可以指定为 exec, eval, single。
  flags -- 变量作用域，局部命名空间，如果被提供，可以是任何映射对象。
  flags和dont_inherit是用来控制编译源码时的标志。
  ```

* 示例

  * ```python
    func_def = """
    def add(x, y):
        return x + y
    print(add(3, 5))
    """
    cm = compile(func_def, '<string>', 'exec')
    exec(cm)
    # 结果：8
    ```

  * 解析

    * ```
      func_de经过compile编译得到字节码
      cm即code对象：True == isinstance(cm, types.CodeType)
      ```

## 7.2 生成Ast对象

* 示例

  * ```python
    
    ```

    