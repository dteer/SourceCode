# 1. 三元表达式

* 1.另一种if判断

  ```python
  print("a" and "b" or "c", "" and "/d/")
  print("" and "b" or "c", "" and "/d/")
  ```

* 结果

  ```markdown
  b
  c /d/
  ```

# 2. 正则

## 2.1 re.VERBOSE使用

* ```python
  _rule_re = re.compile(
  	r"""
  		(?aa)
  		<
  		(?:
  			(a)
  			(b)
  		)?
  		(?ji)
  	""",
      re.VERBOSE,
  )
  ```

* 作用

  * ```
    可以把正则表达式写成多行，并且自动忽略空格
    ```

  ## 2.2 re.UNICODE：全球通用的，统一的

  * ```python
    # 设置，就会影响到\w,\W,\b,\B,\d,\D,\s,\S
    _rule_re = re.compile(
    	r"""
    		(?aa)
    		<
    		(?:
    			(a)
    			(b)
    		)?
    		(?ji)
    	""",
        re.UNICODE,
    )
    ```

*  



## 2.3 非捕获元

* 非捕获元

  * ```python
    (?:...)  	正则括号的非捕获版本。 匹配在括号内的任何正则表达式，但该分组所匹配的子字符串 不能 在执行匹配后被获取或是之后在模式中被引用
    (?=...)		正向预查，匹配...的内容，但是并不消费样式的内容
    (?!...)		反向预查，匹配...不符合的情况
    ```

* (?=...)

  * ```python
    # Isaac (?=Asimov) 匹配 'Isaac ' 只有在后面是 'Asimov' 的时候
    data = re.findall(r'Isaac (?=Asimov)', "Isaac Asimov")
    print(data)
    
    #结果：['Isaac ']
    ```

* (?!...)

  * ```python
    # Isaac (?!Asimov) 只有后面 不 是 'Asimov' 的时候才匹配 'Isaac '
    data = re.findall(r'Isaac (?!Asimov)', "Isaac Asimov")
    print(data)
    
    #结果：[]
    ```

* (?:...)

  * ```python
    # 匹配到的内容不被引用
    content = "http://google0.com http://code.google1.com"
    data = re.findall(r'http://(?:\w+\.)*(\w+\.com)', content)
    print(data)
    
    # 结果：['google0.com', 'google1.com']
    ```

    

