# 1. Map中的endpoint-Rule支持一对多（未解答）

* 代码

  * ```python
    # routing.py 中 Map-add
    self._rules_by_endpoint.setdefault(rule.endpoint, []).append(rule)
    # _rules_by_endpoint = {"index":[<Rule '/' (GET, HEAD) -> index>, <Rule '/about' (GET, HEAD) -> index>]}
    ```

* 疑问

  * 为啥要支持这样做，endpoint不是唯一值吗，这样做的意义是？

* 解答

  *  

# 2. Rule中rulefactory工厂模式的意义

* 代码

  * ```python
    # routing.py 中Rule-get_rules
    def get_rules(self, map):
        yield self
    ```

* 疑问

  * 为啥要做Rule可迭代，这样做有啥意义

* 解答

  *  

# 3.werkzeug路由中Ast

* 代码

  * ```
    # routing.py 中的 Rule-build，Rule-_prefix_names，Rule-_get_func_code，Rule-_compile_builder
    ```

    

* 疑问
  
  * 为啥要引入Ast模块，这样做有啥意义
* 解答
  
  *  



# 4. 子域名+启用主机匹配功能实现

> 开启默认重定向defaults=...
>
> ```python
> url_map = Map(default_subdomain="simple.com")
> url_map.add(Rule('/all/', defaults={'page': 1}, endpoint='all_entries'))
> url_map.add(Rule('/all/page/<int:page>', endpoint='all_entries'))
> ```

* 代码

  * ```python
    # routing.py 中 MapAdapter-get_default_redirect  MapAdapter-make_redirect_url
    
    # routing.py 中 MapAdapter-match中
    if self.map.redirect_defaults:
        redirect_url = self.get_default_redirect(rule, method, rv, query_args)
        if redirect_url is not None:
            raise RequestRedirect(redirect_url)
    
    ```

* 疑问

  * 既然有了可选的默认重定向并拿到了具体的url，为什么还要异常处理

* 解答

  *  

# 5. 如果开启重定向操作

> Rule(redirect_to="ddd")



* 解答 
  *  

# 6. 路由排序

* 这里涉及到一个排序问题，其他代码根据排序做对应的操作

* 代码

  * ```python
    # routing.py 中 MapAdapter-get_default_redirect
    # 如果存在静态url，排序在前，则不会break
    for r in self.map._rules_by_endpoint[rule.endpoint]:
        if r is rule:
            break
    ```




# 7.设置转换器

> 修改Map的默认转换器

* 代码

  * ```python
    #routing.py中 Map-__init__
    self.converters = self.default_converters.copy()
    if converters:
        self.converters.update(converters)
    
    ```

    

* 疑问
  * 为什么要用对象去装饰转换器，self.default_converters.copy()看似和这些对象无关
* 解答
  *  

# 8.代码之间的映射

* 关系表

  * ```json
    {
        Map:{
            self._rules = [rule_obj,...],
        	self._rules_by_endpoint = {"endpoint":[rule_obj,...]}	# app()：添加路由
        },
    	Rule:{
            self.map = Map()	# bind()做的事：将url绑到map
        }
    }
    ```

    

* 一条url的规则解刨过程

  ```python
  # rule.string = /all/page/<int:page>
  # 1.Rule和Map的绑定
  Map.add(rule) 
  	rule.bind()
  #2.转换器对象的生成 Rule.compile - Rule.get_converter
  	#variable=url的变量，converter=转换器的key
      #c_args=转换器的参数args，c_kwargs=转换器的参数kwargs
  convobj = self.get_converter(variable, converter, c_args, c_kwargs)
  ```

  

  1. Rule-compile

  * 参数

    * ```python
      #这是局部保存，每次执行compile会重置
      self._trace	#区分url是动态数据和是静态数据：[(False,"/"),(True,"url的变量")]
      self._converters = {}	# 存储转换器对象：{"url变量":转换器对象}
      self._static_weight = []	# url静态数据的长度：[(索引,-静态数据长度)]
      self._argument_weight = []	# 转换器的权重值：[50,]	# int的转化器是：50
      regex_parts = []	# 这是把url规则解析成可匹配的正则表达式
      # 示例：/all/page/<int(signed=True):page>
      regex_parts = ['\\|', '/+?', 'all', '/+?', 'page', '/+?', '(?P<page>-?\\d+)']
      
      # 全局保存
      self.arguments={}	# {"url的变量"}
      self._regex = "..."	#把规则url解析成可匹配的正则表达式
      ```

  * parse_rule(rule)：正则匹配

    * ```python
      # rule.string:/all/page/<int:page>
      # 返回形式一
      converter, arguments, variable = 转换器的key, 转换器的参数/None, url的变量值
      # 返回形式二
      converter, arguments, variable = None, None, 静态值
      ```

* 一条需要url匹配过程

  1. url_map = Map()

  2. urls = url_map.bind()

  3. urls.match(path_info="/all")

     * 参数

       * ```python
         # MapAdapter-mach
         for rule in self.map._rules:
         try:
         	rv = rule.match(path, method)
         ...
         
         # Rule-match	
         # 检查...并生成url的变量字典
         ```

         