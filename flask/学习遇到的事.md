# 1. Map中的endpoint-Rule支持一对多（未解答）

* 代码

  * ```python
    # routing.py 中 Map-add
    self._rules_by_endpoint.setdefault(rule.endpoint, []).append(rule)
    # _rules_by_endpoint = {"index":[<Rule '/' (GET, HEAD) -> index>, <Rule '/about' (GET, HEAD) -> index>]}
    ```

* 疑问

  * 为啥要支持这样做，endpoint不是唯一值吗，这样做的意义是？

* 解答

  *  

# 2. Rule中rulefactory工厂模式的意义

* 代码

  * ```python
    # routing.py 中Rule-get_rules
    def get_rules(self, map):
        yield self
    ```

* 疑问

  * 为啥要做Rule可迭代，这样做有啥意义

* 解答

  *  

# 3.werkzeug路由中Ast

* 代码

  * ```
    # routing.py 中的 Rule-build，Rule-_prefix_names，Rule-_get_func_code，Rule-_compile_builder
    ```

    

* 疑问
  
  * 为啥要引入Ast模块，这样做有啥意义
* 解答
  
  *  



# 4. 子域名+启用主机匹配功能实现

> 开启默认重定向defaults=...
>
> ```python
> url_map = Map(default_subdomain="simple.com")
> url_map.add(Rule('/all/', defaults={'page': 1}, endpoint='all_entries'))
> url_map.add(Rule('/all/page/<int:page>', endpoint='all_entries'))
> ```

* 代码

  * ```python
    # routing.py 中 MapAdapter-get_default_redirect  MapAdapter-make_redirect_url
    
    # routing.py 中 MapAdapter-match中
    if self.map.redirect_defaults:
        redirect_url = self.get_default_redirect(rule, method, rv, query_args)
        if redirect_url is not None:
            raise RequestRedirect(redirect_url)
    
    ```

* 疑问

  * 既然有了可选的默认重定向并拿到了具体的url，为什么还要异常处理

* 解答

  *  

# 5. 如果开启重定向操作

> Rule(redirect_to="ddd")



* 解答 
  *  

# 6. 路由排序

* 这里涉及到一个排序问题，其他代码根据排序做对应的操作

* 代码

  * ```python
    # routing.py 中 MapAdapter-get_default_redirect
    # 如果存在静态url，排序在前，则不会break
    for r in self.map._rules_by_endpoint[rule.endpoint]:
        if r is rule:
            break
    ```

    